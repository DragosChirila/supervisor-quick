{"name":"supervisor-quick","tagline":"Bypass supervisor's nasty callbacks stack and make it quick!","body":"supervisor-quick\r\n================\r\n\r\nBypass supervisor's nasty callbacks stack and make it quick!\r\n\r\n\r\nUsage\r\n-----\r\n\r\n```bash\r\n$ pip install supervisor-quick\r\n```\r\n\r\nAnd add the following config to `supervisord.conf`.\r\n\r\n```ini\r\n[ctlplugin:quick]\r\nsupervisor.ctl_factory = supervisor_quick:make_quick_controllerplugin\r\n```\r\n\r\nThen start `supervisorctl` and use `quickstart` and `quickstop` to\r\nstart/stop processes.\r\n\r\n```\r\n> quickstart app:0\r\n> quickstart app:\r\n> quickstart ap*\r\n> quickstart all\r\n\r\n> quickstop app:1\r\n> quickstop app:\r\n> quickstop ap*\r\n> quickstop all\r\n```\r\n\r\nIt effects `supervisorctl`, so you don't have to restart the whole\r\nsupervisord to make it work.\r\n\r\n\r\nWhy\r\n---\r\n\r\nI write this plugin because supervisor is just tooooo slow in\r\nstop/start app server in our prod servers.\r\n\r\nAnd I checked the source code and found it is because of the\r\nnasty callbacks stack, and this is a quote from source code\r\n`supervisor/rpcinterface.py`.\r\n\r\n> XXX the above implementation has a weakness inasmuch as the\r\nfirst call into each individual process callback will always\r\nreturn NOT_DONE_YET, so they need to be called twice. The\r\nsymptom of this is that calling this method causes the\r\nclient to block for much longer than it actually requires to\r\nkill all of the running processes. After the first call to\r\nthe killit callback, the process is actually dead, but the\r\nabove killall method processes the callbacks one at a time\r\nduring the select loop, which, because there is no output\r\nfrom child processes after e.g. stopAllProcesses is called,\r\nis not busy, so hits the timeout for each callback. I\r\nattempted to make this better, but the only way to make it\r\nbetter assumes totally synchronous reaping of child\r\nprocesses, which requires infrastructure changes to\r\nsupervisord that are scary at the moment as it could take a\r\nwhile to pin down all of the platform differences and might\r\nrequire a C extension to the Python signal module to allow\r\nthe setting of ignore flags to signals.\r\n\r\nAnd this plugin will do a `quick` start/stop action that bypass\r\nall the callback checks, making it lightning fast.\r\n\r\nIt also have wildcard concurrent execution support, keeping it fast\r\nregardless of processes amount. (This function is inspired by\r\n[supervisor-wildcards](https://github.com/aleszoulek/supervisor-wildcards))\r\n\r\n\r\nExample\r\n-------\r\n\r\nAn example time demo for a app server with numprocs set to 32 to show how quick\r\nsupervisor can be with `quick` command.\r\n\r\n```bash\r\n$ supervisorctl status\r\napp:0                            STOPPED\r\napp:1                            STOPPED\r\napp:10                           STOPPED\r\n......\r\napp:7                            STOPPED\r\napp:8                            STOPPED\r\napp:9                            STOPPED\r\n\r\n$ time supervisorctl start app:\r\n24: started\r\n25: started\r\n26: started\r\n......\r\n18: started\r\n31: started\r\n30: started\r\nsupervisorctl start app:  0.06s user 0.02s system 0% cpu 48.442 total\r\n\r\n$ time supervisorctl stop app:\r\n24: stopped\r\n25: stopped\r\n26: stopped\r\n......\r\n18: stopped\r\n31: stopped\r\n30: stopped\r\nsupervisorctl stop app:  0.06s user 0.03s system 0% cpu 36.278 total\r\n\r\n$ time supervisorctl quickstart app:\r\napp:25: started\r\napp:24: started\r\napp:27: started\r\n......\r\napp:1: started\r\napp:8: started\r\napp:9: started\r\nsupervisorctl quickstart app:  0.09s user 0.03s system 19% cpu 0.618 total\r\n\r\n$ time supervisorctl quickstop app:\r\napp:26: stoped\r\napp:27: stoped\r\napp:22: stoped\r\n......\r\napp:0: stoped\r\napp:9: stoped\r\napp:8: stoped\r\nsupervisorctl quickstop app:  0.09s user 0.04s system 68% cpu 0.196 total\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}